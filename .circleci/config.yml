version: 2.1  # CircleCI version

executors:
  terraform-executor:
    docker:
      - image: hashicorp/terraform:latest
    working_directory: ~/repo

jobs:
  terraform-apply:
    executor: terraform-executor
    steps:
      - checkout  # Pull the latest code from the repository

      # Install AWS CLI to allow Terraform to interact with AWS resources
      - run:
          name: Install AWS CLI
          command: |
            apk add --no-cache aws-cli
            aws --version  # Verify installation  
      
      # Initialize Terraform and  Apply changes automatically
      - run:
          name: Terraform Apply
          command: |
            cd terraform
            terraform init
            terraform plan -lock=false
            terraform apply -auto-approve -lock=false
            cd ..


      # Step 4: Retrieve Terraform Outputs
      - run:
          name: Get Terraform Outputs
          command: |
            # Get the latest commit message (which triggered this pipeline)
            COMMIT_MSG=$(git log -1 --pretty=%B)

            # Extract the database name from the commit message (matching PR format)
            NEW_DB_NAME=$(echo "$COMMIT_MSG" | sed -nE 's/Auto-generated PR to provision RDS instance `([^`]*)`.*/\1/p')

            if [ -z "$NEW_DB_NAME" ]; then
              echo "No new environment found from commit message, skipping."
              exit 0
            fi

            cd terraform
            
            DB_SECRET_ARN=$(terraform output -json rds_secrets_arns | jq -r --arg db "$NEW_DB_NAME" '.[$db]')
            echo "DB_SECRET_ARN=$DB_SECRET_ARN" >> $BASH_ENV

            SLACK_ID=$(grep -A 2 "$NEW_DB_NAME" terraform.tfvars | awk -F '"' '/slack_id/ {print $6}')

            echo "SLACK_ID=$SLACK_ID" >> $BASH_ENV
            cd ..
      - run:
          name: Send Slack Notification
          command: |
            if [ -z "$SLACK_BOT_TOKEN" ] || [ -z "$SLACK_ID" ]; then
              echo "Skipping Slack Notification because SLACK_BOT_TOKEN or SLACK_ID is empty."
              exit 0
            fi
            apk add --no-cache curl

            # AWS CLI command to retrieve the secret value
            AWS_CLI_CMD="aws secretsmanager get-secret-value --secret-id $DB_SECRET_ARN --query 'SecretString' --output text"

            apk add --no-cache curl

            curl -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "channel": "'"$SLACK_ID"'",
              "text": "ðŸš€ *New RDS Secret Created!*",
              "attachments": [
                {
                  "color": "#36a64f",
                  "fields": [
                    {
                      "title": "ðŸ”— Secret ARN",
                      "value": "'"$DB_SECRET_ARN"'",
                      "short": false
                    },
                    {
                      "title": "ðŸ“Œ Retrieve Secret via AWS CLI",
                      "value": "```'"$AWS_CLI_CMD"'```",
                      "short": false
                    }
                  ]
                }
              ]
            }'
      - run:
          name: Identify Old Non-Prod Databases
          command: |
            DAYS_TO_KEEP=0  # Number of days before marking environments as old
            apk add --no-cache jq
            cd terraform

            # Get the current date in seconds since epoch
            CURRENT_DATE=$(date +%s)

            # Store Terraform output directly in a variable
            terraform init
            RDS_CREATION_DATES=$(terraform output -json rds_creation_dates)

            # Initialize an empty array for old databases
            export OLD_DBS=""

            # Process each database instance
            echo "$RDS_CREATION_DATES" | jq -c 'to_entries[]' | while read -r entry; do
              DB_NAME=$(echo "$entry" | jq -r '.key')

              # Check if this DB is marked as prod in terraform.tfvars
              if grep -q "$DB_NAME" terraform.tfvars | grep -q 'environment = "prod"'; then
                echo "$DB_NAME is a prod environment, skipping."
                continue
              fi

              CREATION_DATE=$(echo "$entry" | jq -r '.value')

              # Convert CreationDate to epoch time
              CREATION_DATE_EPOCH=$(date -d "$(echo "$CREATION_DATE" | sed -E 's/T/ /; s/Z//')" +%s)

              # Calculate age in days
              AGE_DAYS=$(( (CURRENT_DATE - CREATION_DATE_EPOCH) / 86400 ))



              if [ "$AGE_DAYS" -ge "$DAYS_TO_KEEP" ]; then
                echo "$DB_NAME is older than $DAYS_TO_KEEP days and not prod, adding to list."
                export OLD_DBS="$OLD_DBS $DB_NAME"
              fi
            done
            echo $OLD_DBS
            # Convert the array to a space-separated string and store it in the environment
            echo "OLD_DBS=\"$OLD_DBS\"" >> $BASH_ENV
            cd ..
      - run:
          name: Comment Out Old Databases in terraform.tfvars
          command: |
            # Load OLD_DBS from environment variable
            source $BASH_ENV

            # Exit early if there are no old databases
            if [ -z "$OLD_DBS" ]; then
              echo "No old databases to mark as deprecated. Skipping."
              exit 0
            fi
            
            cd terraform
            TFVARS_FILE="terraform.tfvars"

            # Initialize PR_BODY message
            PR_BODY="This PR automatically comments out the following environments older than $DAYS_TO_KEEP days:\n\n"

            # Loop through each old database and comment it out
            for DB_NAME in $OLD_DBS; do
              echo "Commenting out $DB_NAME in terraform.tfvars..."
              sed -i "/$DB_NAME = {/ s/^/# /" $TFVARS_FILE
              PR_BODY+="- $DB_NAME\n"
            done

            cd ..
      - run:
          name: Create PR for Deprecated Environments
          command: |
            source $BASH_ENV
            if [ -z "$PR_BODY" ]; then
              echo "No changes detected, skipping PR creation."
              exit 0
            fi

            cd terraform

            # Configure Git
            git config --global user.email "circleci-bot@example.com"
            git config --global user.name "CircleCI Bot"

            # Create a new branch
            BRANCH_NAME="cleanup-old-environments-$(date +%Y%m%d%H%M%S)"
            git checkout -b "$BRANCH_NAME"

            # Commit changes
            git add terraform.tfvars
            git commit -m "Mark old environments as deprecated in terraform.tfvars"

            # Push branch to origin
            git push origin "$BRANCH_NAME"

            # Create Pull Request via GitHub API
            PR_TITLE="Mark old environments as deprecated"

            curl -X POST -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/pulls \
              -d '{
                "title": "'"$PR_TITLE"'",
                "body": "'"$PR_BODY"'",
                "head": "'"$BRANCH_NAME"'",
                "base": "main"
              }'

            cd ..


workflows:
  version: 2
  apply-on-merge:
    jobs:
      - terraform-apply:
          filters:
            branches:
              only: main  # This workflow triggers ONLY when merging into `main`
